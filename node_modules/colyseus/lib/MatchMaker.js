"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var memshared = require("memshared");
var EventEmitter = require("events");
var ws_1 = require("./ws");
var Utils_1 = require("./Utils");
var index_1 = require("./index");
var Protocol_1 = require("./Protocol");
var Debug_1 = require("./Debug");
;
var RegisteredHandler = /** @class */ (function (_super) {
    __extends(RegisteredHandler, _super);
    function RegisteredHandler(klass, options) {
        var _this = _super.call(this) || this;
        _this.klass = klass;
        _this.options = options;
        return _this;
    }
    return RegisteredHandler;
}(EventEmitter));
exports.RegisteredHandler = RegisteredHandler;
var MatchMaker = /** @class */ (function () {
    function MatchMaker() {
        this.handlers = {};
        this.availableRooms = {};
        this.roomsById = {};
        // room references by client id
        this.sessions = {};
        this.isGracefullyShuttingDown = false;
    }
    MatchMaker.prototype.bindClient = function (client, roomId) {
        var _this = this;
        var roomPromise = this.onJoin(roomId, client);
        // register 'close' event early on. the client might disconnect before
        // successfully joining the requested room
        client.on('close', function (_) { return _this.onLeave(client, roomId); });
        roomPromise.then(function (room) {
            client.on('message', function (message) {
                if (!(message = Protocol_1.decode(message))) {
                    return;
                }
                _this.execute(client, message);
            });
        }).catch(function (err) {
            // application level error
            if (err instanceof Error) {
                err = err.message;
            }
            Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ERROR, roomId, err]);
            client.close();
        });
        return roomPromise;
    };
    MatchMaker.prototype.execute = function (client, message) {
        if (message[0] == Protocol_1.Protocol.JOIN_ROOM) {
            this.onJoinRoomRequest(message[1], message[2], false, function (err, room) {
                if (err) {
                    var roomId = (room) ? room.roomId : message[1];
                    Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ERROR, roomId, err]);
                }
            });
        }
        else if (message[0] == Protocol_1.Protocol.ROOM_DATA) {
            // send message directly to specific room
            var room = this.getRoomById(message[1]);
            if (room) {
                room.onMessage(client, message[2]);
            }
        }
        else {
            this.sessions[client.sessionId].onMessage(client, message);
        }
    };
    /**
     * Create/joins a particular client in a room running in a worker process.
     *
     * The client doesn't join instantly because this method is called from the
     * match-making process. The client will request a new WebSocket connection
     * to effectively join into the room created/joined by this method.
     */
    MatchMaker.prototype.onJoinRoomRequest = function (roomToJoin, clientOptions, allowCreateRoom, callback) {
        var room;
        var err;
        clientOptions.sessionId = index_1.generateId();
        if (this.hasHandler(roomToJoin)) {
            room = this.getAvailableRoomByScore(roomToJoin, clientOptions).room
                || (allowCreateRoom && this.create(roomToJoin, clientOptions));
        }
        else if (index_1.isValidId(roomToJoin)) {
            room = this.joinById(roomToJoin, clientOptions);
        }
        if (room) {
            // Reserve a seat for clientId
            room.connectingClients[clientOptions.clientId] = clientOptions;
        }
        else {
            err = "join_request_fail";
        }
        callback(err, room);
    };
    /**
     * Binds target client to the room running in a worker process.
     */
    MatchMaker.prototype.onJoin = function (roomId, client) {
        var _this = this;
        var room = this.roomsById[roomId];
        var clientOptions = room && room.connectingClients[client.id];
        return new Promise(function (resolve, reject) {
            if (room && clientOptions) {
                // assign sessionId to socket connection.
                client.sessionId = clientOptions.sessionId;
                // clean temporary data
                delete clientOptions.sessionId;
                delete clientOptions.clientId;
                var isVerified = room.verifyClient(client, clientOptions);
                if (!(isVerified instanceof Promise)) {
                    isVerified = (isVerified)
                        ? Promise.resolve()
                        : Promise.reject(undefined);
                }
                var onVerifyFailure_1 = function (err) {
                    err = err || "verifyClient failed.";
                    Debug_1.debugMatchMaking("JOIN_ERROR: " + err + " (roomId: %s, clientOptions: %j)", roomId, clientOptions);
                    room._disposeIfEmpty();
                    reject(err);
                };
                isVerified.then(function (result) {
                    //
                    // promise returned falsy value
                    //
                    if (result === false) {
                        return onVerifyFailure_1();
                    }
                    //
                    // client may have disconnected before 'verifyClient' is complete
                    //
                    if (client.readyState !== ws_1.default.OPEN) {
                        return reject("client already disconnected");
                    }
                    room._onJoin(client, clientOptions);
                    room.once('leave', _this.onClientLeaveRoom.bind(_this, room));
                    _this.sessions[client.sessionId] = room;
                    // emit 'join' on registered handler
                    _this.handlers[room.roomName].emit("join", room, client);
                    resolve(room);
                }).catch(onVerifyFailure_1).then(function () {
                    // clean reserved seat only after verifyClient succeeds
                    delete room.connectingClients[client.id];
                });
            }
            else {
                var err = "trying to join non-existing room";
                Debug_1.debugMatchMaking("JOIN_ERROR: " + err + " (roomId: %s, clientOptions: %j)", roomId, clientOptions);
                reject(err);
            }
        });
    };
    MatchMaker.prototype.onLeave = function (client, roomId) {
        var room = this.roomsById[roomId];
        if (!room) {
            // TODO: when gracefully shutting down, _onLeave is called manually per client,
            // and the room may not exist anymore when receiving the 'close' event.
            return;
        }
        room._onLeave(client, true);
        // emit 'leave' on registered handler
        this.handlers[room.roomName].emit("leave", room, client);
    };
    MatchMaker.prototype.onClientLeaveRoom = function (room, client, isDisconnect) {
        if (isDisconnect) {
            return true;
        }
        delete this.sessions[client.sessionId];
    };
    MatchMaker.prototype.registerHandler = function (name, klass, options) {
        if (options === void 0) { options = {}; }
        memshared.sadd("handlers", name);
        var registeredHandler = new RegisteredHandler(klass, options);
        this.handlers[name] = registeredHandler;
        this.availableRooms[name] = [];
        return registeredHandler;
    };
    MatchMaker.prototype.hasHandler = function (name) {
        return this.handlers[name] !== undefined;
    };
    MatchMaker.prototype.hasAvailableRoom = function (roomName) {
        return (this.availableRooms[roomName] &&
            this.availableRooms[roomName].length > 0);
    };
    MatchMaker.prototype.getRoomById = function (roomId) {
        return this.roomsById[roomId];
    };
    MatchMaker.prototype.joinById = function (roomId, clientOptions) {
        var room = this.roomsById[roomId];
        if (!room) {
            console.error("Error: trying to join non-existant room \"" + roomId + "\"");
        }
        else if (room.maxClientsReached) {
            console.error("Error: roomId \"" + roomId + "\" reached maxClients.");
            room = undefined;
        }
        else if (!room.requestJoin(clientOptions, false)) {
            console.error("Error: can't join \"" + room.roomName + "\" with options: " + JSON.stringify(clientOptions));
            room = undefined;
        }
        return room;
    };
    MatchMaker.prototype.getAvailableRoomByScore = function (roomName, clientOptions) {
        var room;
        var bestScore = 0;
        if (this.hasAvailableRoom(roomName)) {
            this.availableRooms[roomName].forEach(function (availableRoom) {
                // check maxClients before requesting to join.
                if (availableRoom.maxClientsReached) {
                    return;
                }
                var score = availableRoom.requestJoin(clientOptions, false);
                if (score > bestScore) {
                    bestScore = score;
                    room = availableRoom;
                }
            });
        }
        return {
            room: room,
            score: bestScore
        };
    };
    MatchMaker.prototype.create = function (roomName, clientOptions) {
        var room = null, registeredHandler = this.handlers[roomName];
        room = new registeredHandler.klass();
        // set room options
        room.roomId = index_1.generateId();
        room.roomName = roomName;
        if (room.onInit) {
            room.onInit(Utils_1.merge({}, clientOptions, registeredHandler.options));
        }
        // cache on which process the room is living.
        memshared.set(room.roomId, process.pid);
        // imediatelly ask client to join the room
        if (room.requestJoin(clientOptions, true)) {
            Debug_1.debugMatchMaking("spawning '%s' on worker %d", roomName, process.pid);
            room.on('lock', this.lockRoom.bind(this, roomName, room));
            room.on('unlock', this.unlockRoom.bind(this, roomName, room));
            room.once('dispose', this.disposeRoom.bind(this, roomName, room));
            this.roomsById[room.roomId] = room;
            // room always start unlocked
            this.createRoomReferences(roomName, room);
            registeredHandler.emit("create", room);
        }
        else {
            room._dispose();
            room = null;
        }
        return room;
    };
    MatchMaker.prototype.lockRoom = function (roomName, room) {
        if (this.clearRoomReferences(roomName, room)) {
            // emit public event on registered handler
            this.handlers[room.roomName].emit("lock", room);
        }
    };
    MatchMaker.prototype.unlockRoom = function (roomName, room) {
        if (this.createRoomReferences(roomName, room)) {
            // emit public event on registered handler
            this.handlers[room.roomName].emit("unlock", room);
        }
    };
    MatchMaker.prototype.disposeRoom = function (roomName, room) {
        Debug_1.debugMatchMaking("disposing '%s' on worker %d", roomName, process.pid);
        // emit disposal on registered session handler
        this.handlers[roomName].emit("dispose", room);
        delete this.roomsById[room.roomId];
        // remove from cache
        memshared.del(room.roomId);
        // remove from available rooms
        this.clearRoomReferences(roomName, room);
    };
    MatchMaker.prototype.createRoomReferences = function (roomName, room) {
        if (this.availableRooms[roomName].indexOf(room) === -1) {
            this.availableRooms[roomName].push(room);
            // flag current worker has this room name
            memshared.sadd(room.roomName, process.pid);
            // increase number of rooms spawned on this worker
            memshared.incr(process.pid.toString());
            return true;
        }
    };
    MatchMaker.prototype.clearRoomReferences = function (roomName, room) {
        var hasDisposed = false;
        if (this.hasAvailableRoom(roomName)) {
            var roomIndex = this.availableRooms[roomName].indexOf(room);
            if (roomIndex !== -1) {
                // decrease number of rooms spawned on this worker
                memshared.decr(process.pid.toString());
                hasDisposed = true;
            }
            Utils_1.spliceOne(this.availableRooms[roomName], roomIndex);
        }
        //
        // if current worker doesn't have any 'roomName' handlers available
        // anymore, remove it from the list.
        //
        if (!this.hasAvailableRoom(roomName)) {
            memshared.srem(room.roomName, process.pid);
        }
        return hasDisposed;
    };
    MatchMaker.prototype.gracefullyShutdown = function () {
        if (this.isGracefullyShuttingDown) {
            return Promise.reject(false);
        }
        this.isGracefullyShuttingDown = true;
        var promises = [];
        for (var roomId in this.roomsById) {
            var room = this.roomsById[roomId];
            // disable autoDispose temporarily, which allow potentially retrieving a
            // Promise from user's `onDispose` method.
            room.autoDispose = false;
            promises.push(room.disconnect());
            promises.push(room._dispose());
            room.emit('dispose');
        }
        return Promise.all(promises);
    };
    return MatchMaker;
}());
exports.MatchMaker = MatchMaker;
