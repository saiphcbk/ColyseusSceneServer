"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var parseURL = require("url-parse");
var ws_1 = require("./ws");
var MatchMaker_1 = require("./MatchMaker");
var Protocol_1 = require("./Protocol");
var index_1 = require("./index");
var Worker_1 = require("./cluster/Worker");
var Utils_1 = require("./Utils");
var Server = /** @class */ (function () {
    function Server(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.matchMaker = new MatchMaker_1.MatchMaker();
        this._onShutdown = function () { return Promise.resolve(); };
        this.onConnection = function (client, req) {
            //
            // TODO: DRY (Worker.ts)
            // ensure URL is parsed.
            //
            // compatibility with ws@3.x.x / uws
            if (req) {
                client.upgradeReq = req;
            }
            var url = parseURL(client.upgradeReq.url, true);
            client.upgradeReq.url = url;
            client.upgradeReq.roomId = url.pathname.substr(1);
            Worker_1.setUserId(client);
            var roomId = client.upgradeReq.roomId;
            if (roomId) {
                _this.matchMaker.bindClient(client, roomId);
            }
            else {
                client.on("message", _this.onMessageMatchMaking.bind(_this, client));
            }
        };
        Utils_1.registerGracefulShutdown(function (signal) {
            _this.matchMaker.gracefullyShutdown().
                then(function () { return _this._onShutdown(); }).
                catch(function (err) { return console.log("ERROR!", err); }).
                then(function () { return process.exit(); });
        });
        if (options.server) {
            this.attach({ server: options.server });
        }
    }
    Server.prototype.attach = function (options) {
        if (options.server || options.port) {
            this.server = new ws_1.WebSocketServer(options);
            this.httpServer = options.server;
        }
        else {
            this.server = options.ws;
        }
        this.server.on('connection', this.onConnection);
    };
    Server.prototype.listen = function (port, hostname, backlog, listeningListener) {
        this.httpServer.listen(port, hostname, backlog, listeningListener);
    };
    Server.prototype.register = function (name, handler, options) {
        if (options === void 0) { options = {}; }
        return this.matchMaker.registerHandler(name, handler, options);
    };
    Server.prototype.onShutdown = function (callback) {
        this._onShutdown = callback;
    };
    Server.prototype.onMessageMatchMaking = function (client, message) {
        if (!(message = Protocol_1.decode(message))) {
            return;
        }
        if (message[0] !== Protocol_1.Protocol.JOIN_ROOM) {
            console.error("MatchMaking couldn't process message:", message, message[0]);
            return;
        }
        var roomName = message[1];
        var joinOptions = message[2];
        joinOptions.clientId = client.id;
        if (!this.matchMaker.hasHandler(roomName) && !index_1.isValidId(roomName))
        {
            Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ERROR, roomName, "Error: no available handler for \"" + roomName + "\""]);
        }
        else
        {
            console.log("Player " + joinOptions.clientId + " trying to join room ", roomName, joinOptions);
            this.matchMaker.onJoinRoomRequest(roomName, joinOptions, true, function (err, room) {
                var joinRoomResponse = (err)
                    ? [Protocol_1.Protocol.JOIN_ERROR, roomName, err]
                    : [Protocol_1.Protocol.JOIN_ROOM, room.roomId, joinOptions.requestId];
                Protocol_1.send(client, joinRoomResponse);
            });
        }
    };
    return Server;
}());
exports.Server = Server;
