"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var msgpack = require("notepack.io");
var fossilDelta = require("fossil-delta");
var timer_1 = require("@gamestdio/timer");
var events_1 = require("events");
var timeline_1 = require("@gamestdio/timeline");
var Protocol_1 = require("./Protocol");
var Utils_1 = require("./Utils");
var Debug_1 = require("./Debug");
var jsonPatch = require("fast-json-patch"); // this is only used for debugging patches
var Room = /** @class */ (function (_super) {
    __extends(Room, _super);
    function Room() {
        var _this = _super.call(this) || this;
        _this.clock = new timer_1.default();
        _this.clients = [];
        _this.maxClients = Infinity;
        _this.patchRate = 1000 / 20; // Default patch rate is 20fps (50ms)
        _this.autoDispose = true;
        // holds a list of clients with clientOptions during handshake
        _this.connectingClients = {};
        if (arguments.length > 0) {
            console.warn("DEPRECATION WARNING: use 'onInit(options)' instead of 'constructor(options)' to initialize the room.");
        }
        _this.setPatchRate(_this.patchRate);
        return _this;
    }
    Room.prototype.requestJoin = function (options, isNew) {
        return 1;
    };
    Room.prototype.verifyClient = function (client, options) {
        return Promise.resolve(true);
    };
    Object.defineProperty(Room.prototype, "maxClientsReached", {
        get: function () {
            return this.clients.length + Object.keys(this.connectingClients).length >= this.maxClients;
        },
        enumerable: true,
        configurable: true
    });
    Room.prototype.setSimulationInterval = function (callback, delay) {
        var _this = this;
        if (delay === void 0) { delay = 1000 / 60; }
        // clear previous interval in case called setSimulationInterval more than once
        if (this._simulationInterval)
            clearInterval(this._simulationInterval);
        this._simulationInterval = setInterval(function () {
            _this.clock.tick();
            callback();
        }, delay);
    };
    Room.prototype.setPatchRate = function (milliseconds) {
        // clear previous interval in case called setPatchRate more than once
        if (this._patchInterval)
            clearInterval(this._patchInterval);
        this._patchInterval = setInterval(this.broadcastPatch.bind(this), milliseconds);
    };
    Room.prototype.useTimeline = function (maxSnapshots) {
        if (maxSnapshots === void 0) { maxSnapshots = 10; }
        this.timeline = timeline_1.createTimeline(maxSnapshots);
    };
    Room.prototype.setState = function (newState) {
        this.clock.start();
        this._previousState = newState;
        // ensure state is populated for `sendState()` method.
        //this._previousStateEncoded = msgpack.encode(this._previousState);
        this._previousStateEncoded = JSON.stringify(this._previousState);
        this.state = newState;
        if (this.timeline) {
            this.timeline.takeSnapshot(this.state);
        }
    };
    Room.prototype.lock = function () {
        this.emit('lock');
    };
    Room.prototype.unlock = function () {
        this.emit('unlock');
    };
    Room.prototype.send = function (client, data) {
        Protocol_1.send(client, [Protocol_1.Protocol.ROOM_DATA, this.roomId, data]);
    };
    Room.prototype.broadcast = function (data) {
        // no data given, try to broadcast patched state
        if (!data) {
            throw new Error("Room#broadcast: 'data' is required to broadcast.");
        }
        // encode all messages with msgpack
        //if (!(data instanceof Buffer))
        //{
        if (!(typeof data === 'string')) {
            //data = msgpack.encode([Protocol_1.Protocol.ROOM_DATA, this.roomId, data]);
            data = JSON.stringify([Protocol_1.Protocol.ROOM_DATA, this.roomId, data]);
        }
        var numClients = this.clients.length;
        console.log("broadcast:" + data);
        while (numClients--)
        {
            this.clients[numClients].send(data, { binary: true }, Utils_1.logError.bind(this));
        }
        return true;
    };
    Room.prototype.disconnect = function () {
        var promises = [];
        var i = this.clients.length;
        while (i--) {
            promises.push(this._onLeave(this.clients[i]));
        }
        return Promise.all(promises);
    };
    Room.prototype.sendState = function (client) {
        Protocol_1.send(client, [
            Protocol_1.Protocol.ROOM_STATE,
            this.roomId,
            this._previousStateEncoded,
            this.clock.currentTime,
            this.clock.elapsedTime,
        ]);
    };
    Room.prototype.broadcastPatch = function () {
        if (!this._previousState) {
            Debug_1.debugPatch('trying to broadcast null state. you should call #setState on constructor or during user connection.');
            return false;
        }
        var currentState = this.state;
        //var currentStateEncoded = msgpack.encode(currentState
        var currentStateEncoded = JSON.stringify(currentState);

      
      
        // skip if state has not changed.
        if (currentStateEncoded === (this._previousStateEncoded)) {
            return false;
        }
        var currentStateBackIntoObject = JSON.parse(currentStateEncoded);
        var previousStateBackIntoObject = JSON.parse(this._previousStateEncoded);

        //console.log("previous state encoded:", this._previousStateEncoded);
        //console.log("currentstate encoded:", currentStateEncoded);
        
        //var patches = fossilDelta.create(this._previousStateEncoded, currentStateEncoded);

        var patches = jsonPatch.compare(previousStateBackIntoObject, currentStateBackIntoObject)
        //console.log("patches:", patches);

        // take a snapshot of the current state
        if (this.timeline) {
            this.timeline.takeSnapshot(this.state, this.clock.elapsedTime);
        }
        //
        // debugging
        //
        if (Debug_1.debugPatch.enabled)
        {
          Debug_1.debugPatch("\"%s\" (roomId: \"%s\") is sending %d bytes:", this.roomName, this.roomId, patches.length);
        }
        if (Debug_1.debugPatchData.enabled) {
            Debug_1.debugPatchData(jsonPatch.compare(this._previousState, currentState));
        }
        this._previousState = currentState;
        this._previousStateEncoded = currentStateEncoded;
        // broadcast patches (diff state) to all clients,
        // even if nothing has changed in order to calculate PING on client-side
        //return this.broadcast(msgpack.encode([Protocol_1.Protocol.ROOM_STATE_PATCH, this.roomId, patches]));

        //console.log("broadcast patch:", ([Protocol_1.Protocol.ROOM_STATE_PATCH, this.roomId, patches]))
        return this.broadcast(JSON.stringify([Protocol_1.Protocol.ROOM_STATE_PATCH, this.roomId, patches]));
        
    };
    Room.prototype._onJoin = function (client, options) {
        this.clients.push(client);
        // confirm room id that matches the room name requested to join
        Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ROOM, client.sessionId]);
        // send current state when new client joins the room
        if (this.state) {
            this.sendState(client);
        }
        if (this.onJoin) {
            this.onJoin(client, options);
        }
    };
    Room.prototype._onLeave = function (client, isDisconnect) {
        if (isDisconnect === void 0) { isDisconnect = false; }
        var userReturnData;
        //
        // call abstract 'onLeave' method only if the client has been successfully accepted.
        //
        // the '_onLeave' method may be called before 'verifyClient' succeeds,
        // before the client is appended to `this.clients`
        //
        if (Utils_1.spliceOne(this.clients, this.clients.indexOf(client)) && this.onLeave) {
            userReturnData = this.onLeave(client);
        }
        this.emit('leave', client, isDisconnect);
        //
        // TODO: force disconnect from server.
        //
        // need to check why the connection is being re-directed to MatchMaking
        // process after calling `client.close()` here
        //
        if (!isDisconnect) {
            Protocol_1.send(client, [Protocol_1.Protocol.LEAVE_ROOM, this.roomId]);
        }
        // custom cleanup method & clear intervals
        if (this.autoDispose) {
            this._disposeIfEmpty();
        }
        return userReturnData || Promise.resolve();
    };
    Room.prototype._disposeIfEmpty = function () {
        if (this.clients.length == 0) {
            this._dispose();
            this.emit('dispose');
        }
    };
    Room.prototype._dispose = function () {
        var userReturnData;
        if (this.onDispose)
            userReturnData = this.onDispose();
        if (this._patchInterval)
            clearInterval(this._patchInterval);
        if (this._simulationInterval)
            clearInterval(this._simulationInterval);
        // clear all timeouts/intervals + force to stop ticking
        this.clock.clear();
        this.clock.stop();
        return userReturnData || Promise.resolve();
    };
    return Room;
}(events_1.EventEmitter));
exports.Room = Room;
