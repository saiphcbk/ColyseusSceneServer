"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var msgpack = require("notepack.io");
var Protocol;
(function (Protocol) {
    // Use codes between 0~127 for lesser throughput (1 byte)
    // User-related (1~10)
    Protocol[Protocol["USER_ID"] = 1] = "USER_ID";
    // Cluster messages (server-side)
    Protocol[Protocol["PASS_HTTP_SOCKET"] = 3] = "PASS_HTTP_SOCKET";
    Protocol[Protocol["PASS_WEBSOCKET"] = 4] = "PASS_WEBSOCKET";
    Protocol[Protocol["REQUEST_JOIN_ROOM"] = 8] = "REQUEST_JOIN_ROOM";
    Protocol[Protocol["CREATE_ROOM"] = 9] = "CREATE_ROOM";
    // Room-related (10~20)
    Protocol[Protocol["JOIN_ROOM"] = 10] = "JOIN_ROOM";
    Protocol[Protocol["JOIN_ERROR"] = 11] = "JOIN_ERROR";
    Protocol[Protocol["LEAVE_ROOM"] = 12] = "LEAVE_ROOM";
    Protocol[Protocol["ROOM_DATA"] = 13] = "ROOM_DATA";
    Protocol[Protocol["ROOM_STATE"] = 14] = "ROOM_STATE";
    Protocol[Protocol["ROOM_STATE_PATCH"] = 15] = "ROOM_STATE_PATCH";
    // Generic messages (50~60)
    Protocol[Protocol["BAD_REQUEST"] = 50] = "BAD_REQUEST";
})(Protocol = exports.Protocol || (exports.Protocol = {}));
function decode(message)
{
    //try {
    //    message = msgpack.decode(Buffer.from(message));
    //}
    //catch (e) {
    //    console.error("Couldn't decode message:", message, e.stack);
    //    return;
    //}
    message = JSON.parse(stringFromUTF8Array(message));
    return message;
}
exports.decode = decode;
function send(client, message) {
    //client.send(msgpack.encode(message), { binary: true });
    message = JSON.stringify(message);
    console.log("sending:" + message);
    client.send(message, { binary: true });
}
exports.send = send;

function stringFromUTF8Array(data) {
  const extraByteMap = [1, 1, 1, 1, 2, 2, 3, 0];
  var count = data.length;
  var str = "";

  for (var index = 0; index < count;) {
    var ch = data[index++];
    if (ch & 0x80) {
      var extra = extraByteMap[(ch >> 3) & 0x07];
      if (!(ch & 0x40) || !extra || ((index + extra) > count))
        return null;

      ch = ch & (0x3F >> extra);
      for (; extra > 0; extra -= 1) {
        var chx = data[index++];
        if ((chx & 0xC0) != 0x80)
          return null;

        ch = (ch << 6) | (chx & 0x3F);
      }
    }

    str += String.fromCharCode(ch);
  }

  return str;
}

